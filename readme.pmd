% Algorithm Report 1: Task Scheduling
% Jon Craton

[![Build Status](https://travis-ci.org/jncraton/build-scheduler.svg?branch=master)](https://travis-ci.org/jncraton/build-scheduler)

Scheduling algoritms are important in many areas of Computer Science including CPU design, compiler design[1], and process scheduling. I will explore the task of applying scheduling to optimizing the ordering of dependent production tasks in the game StarCraft: Brood War.

I will try to use CPU architecture metaphors as much as possible throughout this document to try to make as many connections to existing algorithms as possible. Anything that can perform a task will be thought of as an Execution Unit[3]. One unique aspect of scheduling execution unit in the case of Brood War is that our CPU is able to build new execution units on the fly.

We will first apply some traditional algorithms to handle the typical case where the number and type of execution units are fixed.

First, we need to define some units:

```python
from collections import namedtuple

Unit = namedtuple('ExecutionUnit', ['name','executed_on','min','gas','supply','time','requires'])

Nexus = Unit('Nexus','Probe',400,0,-10,75,None)
Assimilator = Unit('Assimilator','Probe',100,0,0,25,None)
Pylon = Unit('Pylon','Probe',100,0,-8,19,None)
Gateway = Unit('Gateway','Probe',150,0,0,38,Pylon)

Probe = Unit('Probe','Nexus',50,0,1,13,None)
Zealot = Unit('Zealot','Gateway',100,0,2,25,None)
```

We also need a little math to calculate income rate based on the current units and structures we possess:

```python
def mining_rate(bases, assimilators, workers):
  """ Returns minerals/sec for a given number of bases, workers, and assimilators 

  https://liquipedia.net/starcraft/Mining

  Check that one base mineral rates scale properly:

  >>> mining_rate(1, 0, 9)
  (9.75, 0.0)
  >>> mining_rate(1, 0, 18)
  (18.0, 0.0)
  >>> mining_rate(1, 0, 27)
  (26.25, 0.0)
  >>> mining_rate(1, 0, 50)
  (26.25, 0.0)

  Check gas rates:

  >>> mining_rate(1, 1, 3)
  (0.0, 5.15)
  >>> mining_rate(1, 2, 6)
  (0.0, 10.3)

  Make sure we don't have any crosstalk between gas and mineral rates:

  >>> mining_rate(1, 1, 12)
  (9.75, 5.15)
  >>> mining_rate(1, 1, 21)
  (18.0, 5.15)
  >>> mining_rate(1, 1, 30)
  (26.25, 5.15)
  >>> mining_rate(1, 1, 50)
  (26.25, 5.15)
  """
  
  min_workers = workers - (assimilators * 3)

  min_workers_per_base = min_workers / bases
  min_per_base = min(min_workers_per_base, 9) * 65/60
  if min_workers_per_base > 9:
    min_per_base += min(min_workers_per_base - 9, 18) * 55/60
      
  return (min_per_base * bases, assimilators * (309 / 60))
```

We'll create a class to wrap our execution units in to track what they are running and how long it will take to finish the work:

```python
class ExecutionUnit:
  def __init__(self, unit):
    self.unit = unit
    self.idle_at = 0
    self.running = None

  def complete(self):
    completed = self.running
    self.running = None
    self.idle_at = 0
  
    return completed

  def run(self, task, res, time):
    self.running = task
    self.idle_at = task.time + time

    res[0] -= task.min
    res[1] -= task.gas
    if task.supply > 0: # Otherwise we adjust supply on completion
      res[2] -= task.supply

  def can_run(self, task, res):
    if task.min > res[0] or task.gas > res[1] or task.supply > res[2]: return False
  
    return not self.running and (task.executed_on == None or self.unit.name==task.executed_on)
```

Now let's add an `execute` function to schedule a set of tasks. This function takes a list of execution units, a list of tasks to complete, and a scheduler function to decide what to run.

```python  
def execute(units, tasks, scheduler, debug=False):
  """
  Executes a set of tasks using a supplied scheduler
  
  >>> execute([Nexus] + [Probe] * 4, [Probe], lambda *x: None)
  13
  >>> execute([Nexus] + [Probe] * 4, [Probe] * 4 + [Pylon, Gateway, Zealot], lambda *x: None)
  126
  >>> execute([Nexus] + [Probe] * 4, [Probe] * 4 + [Pylon, Gateway, Zealot, Nexus, Zealot], lambda *x: None)
  196
  """

  time = -1
  res = [50,0,6]

  eus = [ExecutionUnit(unit) for unit in units]

  def message(msg):
    if debug:
      print('%ds (%d minerals, %d gas, %d supply): %s' % (time, res[0], res[1], res[2], msg))

  for time in range(0,600):
    for eu in eus:
      if eu.running and eu.idle_at <= time:
        message("Completed %s." % eu.running.name)
        if eu.running.supply < 0:
          res[2] -= eu.running.supply
        eus.append(ExecutionUnit(eu.complete()))

    scheduler(eus, tasks, time, res)

    # Begin running the next task if possible
    if tasks:
      for eu in eus:
        if eu.can_run(tasks[0], res):
          message("Started %s" % tasks[0].name)
          eu.run(tasks[0], res, time)
          tasks.pop(0)
          break

    if not tasks and not [idle for idle in eus if idle.running!=None]: return time

    peons = len([t for t in eus if t.unit == Probe])
    bases = len([t for t in eus if t.unit == Nexus])
    gases = len([t for t in eus if t.unit == Assimilator])
    
    res[0] += mining_rate(bases, gases, peons)[0]
    res[1] += mining_rate(bases, gases, peons)[1]

  return time
```

FIFO (In-order execution)
=========================

One of the simplest scheduling algorithms that we can implement is a simple FIFO system:

```python
def fifo(eus, tasks, time, res):
  """
  Assign tasks to execution units in the order they were supplied.

  This is a noop.
  """

  return

INITIAL = [Nexus] + [Probe] * 4
TASKS = [Probe] * 4 + [Pylon] + [Probe] * 4 + [Gateway, Zealot, Zealot]

execute(INITIAL[:], TASKS[:], fifo, debug=True)
```

Reordering (out-of-order execution)
===================================

We'll now implement a simple algorithm to allow future operations to be scheduled if the next operation is blocked. The CPU metaphor is not perfect here, but this borrows the concept of dependency handling and a reservation station from Tomasulo's algorithm. [4][9]

This algorithm is still trivial in terms of both complexity (O(n)) and correctness (everything still runs), so I'll skip formal validation.

```python
def reorder(eus, tasks, time, res):
  """
  Reorders upcoming tasks if the next task is not runnable. This implements the first step of a selection sort to move the first task that can be run to the front of the task queue.

  The algorithm used here is to simply put the first runnable task as the start of the task queue or do nothing
  """

  for (i, task) in enumerate(tasks):
    for eu in eus:
      if eu.can_run(task, res):
        tasks.insert(0, tasks.pop(i))
        return

execute(INITIAL[:], TASKS[:], reorder, debug=True)
```

We were able to remove 13s of stalling on this simple task by simply using reordering.

Operation Directed Acyclic Graph
================================

This is where the more challenging algorithms begin. There are two factors that make this scheduling task complex:

1. Dependencies
2. Exponential benefit

We'll handle dependencies here in some depth and then explore exponential benefit. The first step to handling dependencies in a sensible way is to convert our operations into a directed acyclic graphs (DAG).

```python
import networkx as nx

DAG = nx.DiGraph()

class Node:
  def __init__(self, task):
    self.task = task

  def __str__(self):
    return self.task.name

for task in INITIAL + TASKS:
  DAG.add_node(Node(task))

for n1 in DAG.nodes:
  for n2 in DAG.nodes:
    if n2.task.executed_on == n1.task.name:
      DAG.add_edge(n1,n2)
  
import matplotlib.pyplot as plt

nx.draw(DAG, with_labels=True)

print(nx.nx_agraph.to_agraph(DAG))
```    

References
==========

1. http://www.cl.cam.ac.uk/teaching/2005/OptComp/slides/lecture14.pdf
2. https://en.wikipedia.org/wiki/Scheduling_(computing)
3. https://en.wikipedia.org/wiki/Execution_unit
4. https://www.cc.gatech.edu/fac/milos/Teaching/CS6290F07/4_Tomasulo.pdf
5. https://www.kth.se/social/upload/62/microprocessor_design.pdf
6. https://en.wikipedia.org/wiki/Topological_sorting
7. https://en.wikipedia.org/wiki/Coffman%E2%80%93Graham_algorithm
8. https://en.wikipedia.org/wiki/Job_shop_scheduling
9. https://en.wikipedia.org/wiki/Tomasulo_algorithm