% Algorithm Report 1: Task Scheduling
% Jon Craton

Scheduling algoritms are important in many areas of Computer Science including CPU design, compiler design[1], and process scheduling. I will explore the task of applying scheduling to optimizing the ordering of dependent production tasks in the game StarCraft: Brood War.

I will try to use CPU architecture metaphors as much as possible throughout this document to try to make as many connections to existing algorithms as possible. Anything that can perform a task will be thought of as an Execution Unit[3]. One unique aspect of scheduling execution unit in the case of Brood War is that our CPU is able to build new execution units on the fly.

We will first apply some traditional algorithms to handle the typical case where the number and type of execution units are fixed.

Let's start with some basic execution units and tasks:

```python
from collections import namedtuple

Unit = namedtuple('ExecutionUnit', ['name','executed_on','min','gas','supply','time','requires'])

Nexus = Unit('Nexus','Probe',400,0,-10,75,None)
Assimilator = Unit('Assimilator','Probe',100,0,0,25,None)
Pylon = Unit('Pylon','Probe',100,0,8,19,None)
Gateway = Unit('Gateway','Probe',150,0,0,38,Pylon)

Probe = Unit('Probe','Nexus',50,0,1,13,None)
Zealot = Unit('Zealot','Gateway',100,0,2,25,None)
```

Now let's add an `execute` function to schedule a set of tasks. This function takes a list of execution units, a list of tasks to complete, and a scheduler function to decide what to run.

```python
def mining_rate(bases, assimilators, workers):
  """ Returns minerals/sec for a given number of bases, workers, and assimilators 

  https://liquipedia.net/starcraft/Mining

  Check that one base mineral rates scale properly:

  >>> mining_rate(1, 0, 9)
  (9.75, 0.0)
  >>> mining_rate(1, 0, 18)
  (18.0, 0.0)
  >>> mining_rate(1, 0, 27)
  (26.25, 0.0)
  >>> mining_rate(1, 0, 50)
  (26.25, 0.0)

  Check gas rates:

  >>> mining_rate(1, 1, 3)
  (0.0, 5.15)
  >>> mining_rate(1, 2, 6)
  (0.0, 10.3)

  Make sure we don't have any crosstalk between gas and mineral rates:

  >>> mining_rate(1, 1, 12)
  (9.75, 5.15)
  >>> mining_rate(1, 1, 21)
  (18.0, 5.15)
  >>> mining_rate(1, 1, 30)
  (26.25, 5.15)
  >>> mining_rate(1, 1, 50)
  (26.25, 5.15)
  """
  
  min_workers = workers - (assimilators * 3)

  min_workers_per_base = min_workers / bases
  min_per_base = min(min_workers_per_base, 9) * 65/60
  if min_workers_per_base > 9:
    min_per_base += min(min_workers_per_base - 9, 18) * 55/60
      
  return (min_per_base * bases, assimilators * (309 / 60))

class ExecutionUnit:
  def __init__(self, unit):
    self.unit = unit
    self.idle_at = 0
    self.running = None

  def complete(self, time):
    print('%ds: Completed %s' % (time, self.running.name))
  
    completed = self.running
    self.running = None
    self.idle_at = 0
  
    return completed

  def run(self, task, time):
    self.running = task
    self.idle_at = task.time + time
  
def execute(units, tasks, scheduler):
  time = 0
  min = 50
  gas = 0

  eus = [ExecutionUnit(unit) for unit in units]

  while (tasks or [idle for idle in eus if idle.running!=None]) and time<60:
    for eu in eus:
      if eu.running and eu.idle_at <= time:
        eus.append(ExecutionUnit(eu.complete(time)))

    scheduler(eus, tasks, time)

    peons = len([t for t in eus if t.unit == Probe])
    bases = len([t for t in eus if t.unit == Nexus])
    gases = len([t for t in eus if t.unit == Assimilator])
    
    min += mining_rate(bases, gases, peons)[0]
    gas += mining_rate(bases, gases, peons)[1]
    
    time += 1

  print("Execution complete in %d seconds." % time)

def fifo(eus, tasks, time):
  """ Assign tasks to execution units in the order they were supplied."""

  if not tasks: return

  task = tasks.pop()

  for eu in eus:
    if not eu.running and (task.executed_on == None or eu.unit.name==task.executed_on):
      eu.run(task, time)
      return

  tasks.append(task)

execute([Nexus] + [Probe] * 4,[Probe] * 3 + [Pylon],fifo)
```

#done = [Nexus] + 4 * [Probe]
#todo = 5 * ['zealot'] + 12 * ['probe']


References
==========

1. http://www.cl.cam.ac.uk/teaching/2005/OptComp/slides/lecture14.pdf
2. https://en.wikipedia.org/wiki/Scheduling_(computing)
3. https://en.wikipedia.org/wiki/Execution_unit