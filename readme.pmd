% Algorithm Report 1: Task Scheduling
% Jon Craton

[![Build Status](https://travis-ci.org/jncraton/build-scheduler.svg?branch=master)](https://travis-ci.org/jncraton/build-scheduler)

Scheduling algoritms are important in many areas of Computer Science including CPU design, compiler design[1], and process scheduling. I will explore the task of applying scheduling to optimizing the ordering of dependent production tasks in the game StarCraft: Brood War.

I will try to use CPU architecture metaphors as much as possible throughout this document to try to make as many connections to existing algorithms as possible. Anything that can perform a task will be thought of as an Execution Unit[3]. One unique aspect of scheduling execution unit in the case of Brood War is that our CPU is able to build new execution units on the fly.

We will first apply some traditional algorithms to handle the typical case where the number and type of execution units are fixed.

First, we need to define some units:

```python
from collections import namedtuple

Unit = namedtuple('ExecutionUnit', ['name','executed_on','min','gas','supply','time','requires'])

Nexus = Unit('Nexus','Probe',400,0,-10,75,None)
Assimilator = Unit('Assimilator','Probe',100,0,0,25,None)
Pylon = Unit('Pylon','Probe',100,0,-8,19,None)
Gateway = Unit('Gateway','Probe',150,0,0,38,Pylon)

Probe = Unit('Probe','Nexus',50,0,1,13,None)
Zealot = Unit('Zealot','Gateway',100,0,2,25,None)
```

We also need a little math to calculate income rate based on the current units and structures we possess:

```python
def mining_rate(bases, assimilators, workers):
  """ Returns minerals/sec for a given number of bases, workers, and assimilators 

  https://liquipedia.net/starcraft/Mining

  Check that one base mineral rates scale properly:

  >>> mining_rate(1, 0, 9)
  (9.75, 0.0)
  >>> mining_rate(1, 0, 18)
  (18.0, 0.0)
  >>> mining_rate(1, 0, 27)
  (26.25, 0.0)
  >>> mining_rate(1, 0, 50)
  (26.25, 0.0)

  Check gas rates:

  >>> mining_rate(1, 1, 3)
  (0.0, 5.15)
  >>> mining_rate(1, 2, 6)
  (0.0, 10.3)

  Make sure we don't have any crosstalk between gas and mineral rates:

  >>> mining_rate(1, 1, 12)
  (9.75, 5.15)
  >>> mining_rate(1, 1, 21)
  (18.0, 5.15)
  >>> mining_rate(1, 1, 30)
  (26.25, 5.15)
  >>> mining_rate(1, 1, 50)
  (26.25, 5.15)
  """
  
  min_workers = workers - (assimilators * 3)

  min_workers_per_base = min_workers / bases
  min_per_base = min(min_workers_per_base, 9) * 65/60
  if min_workers_per_base > 9:
    min_per_base += min(min_workers_per_base - 9, 18) * 55/60
      
  return (min_per_base * bases, assimilators * (309 / 60))
```

We'll create a class to wrap our execution units in to track what they are running and how long it will take to finish the work:

```python
class ExecutionUnit:
  def __init__(self, unit):
    self.unit = unit
    self.idle_at = 0
    self.running = None

  def complete(self):
    completed = self.running
    self.running = None
    self.idle_at = 0
  
    return completed

  def run(self, task, res, time):
    self.running = task
    self.idle_at = task.time + time

    res[0] -= task.min
    res[1] -= task.gas
    if task.supply > 0: # Otherwise we adjust supply on completion
      res[2] -= task.supply

  def can_run(self, task, res):
    if task.min > res[0] or task.gas > res[1] or task.supply > res[2]: return False
  
    return not self.running and (task.executed_on == None or self.unit.name==task.executed_on)
```

Now let's add an `execute` function to schedule a set of tasks. This function takes a list of execution units, a list of tasks to complete, and a scheduler function to decide what to run.

```python  
def execute(units, tasks, scheduler, debug=False):
  """
  Executes a set of tasks using a supplied scheduler
  
  >>> execute([Nexus] + [Probe] * 4, [Probe], lambda *x: None)
  13
  >>> execute([Nexus] + [Probe] * 4, [Probe] * 4 + [Pylon, Gateway, Zealot], lambda *x: None)
  126
  >>> execute([Nexus] + [Probe] * 4, [Probe] * 4 + [Pylon, Gateway, Zealot, Nexus, Zealot], lambda *x: None)
  196
  """

  time = -1
  res = [50,0,6]

  eus = [ExecutionUnit(unit) for unit in units]

  for time in range(0,600):
    for eu in eus:
      if eu.running and eu.idle_at <= time:
        if debug:
          print('%ds (%d minerals, %d gas, %d supply): Completed %s' % (time, res[0], res[1], res[2], eu.running.name))
        if eu.running.supply < 0:
          res[2] -= eu.running.supply
        eus.append(ExecutionUnit(eu.complete()))

    scheduler(eus, tasks, time, res)

    # Begin running the next task if possible
    if tasks:
      for eu in eus:
        if eu.can_run(tasks[0], res):
          eu.run(tasks[0], res, time)
          tasks.pop(0)
          break

    if not tasks and not [idle for idle in eus if idle.running!=None]: return time

    peons = len([t for t in eus if t.unit == Probe])
    bases = len([t for t in eus if t.unit == Nexus])
    gases = len([t for t in eus if t.unit == Assimilator])
    
    res[0] += mining_rate(bases, gases, peons)[0]
    res[1] += mining_rate(bases, gases, peons)[1]

  return time
```

FIFO (In-order execution)
=========================

One of the simplest scheduling algorithms that we can implement is a simple FIFO system:

```python
def fifo(eus, tasks, time, res):
  """
  Assign tasks to execution units in the order they were supplied.

  This is a noop.
  """

  return

execute([Nexus] + [Probe] * 4, [Probe] * 4 + [Pylon, Gateway, Zealot, Nexus, Zealot], fifo, debug=True)
```

Reordering (out-of-order execution)
===================================

References
==========

1. http://www.cl.cam.ac.uk/teaching/2005/OptComp/slides/lecture14.pdf
2. https://en.wikipedia.org/wiki/Scheduling_(computing)
3. https://en.wikipedia.org/wiki/Execution_unit
4. https://www.cc.gatech.edu/fac/milos/Teaching/CS6290F07/4_Tomasulo.pdf
5. https://www.kth.se/social/upload/62/microprocessor_design.pdf
6. https://en.wikipedia.org/wiki/Topological_sorting
7. https://en.wikipedia.org/wiki/Coffman%E2%80%93Graham_algorithm
8. https://en.wikipedia.org/wiki/Job_shop_scheduling